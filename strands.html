<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Strands</title>
  <style>
    :root{
      --bg:#0b0c12;
      --panel: rgba(255,255,255,.06);
      --border: rgba(255,255,255,.12);
      --text:#e9ecff;
      --muted: rgba(233,236,255,.65);
      --shadow: 0 18px 50px rgba(0,0,0,.45);

      --tile: rgba(255,255,255,.07);
      --tileHover: rgba(255,255,255,.10);
      --sel: rgba(255,255,255,.18);
      --found: rgba(123,208,139,.22);
      --spangram: rgba(181,140,246,.22);

      --btn: rgba(255,255,255,.08);
      --btnHover: rgba(255,255,255,.11);

      --accent:#78aef5;
      --ok:#7bd08b;
      --warn:#f4c64f;
      --bad:#ff6b6b;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1000px 650px at 14% 10%, rgba(96,165,250,.20), transparent 60%),
        radial-gradient(900px 650px at 86% 75%, rgba(167,139,250,.14), transparent 60%),
        linear-gradient(180deg, #0f1020, var(--bg));
      color: var(--text);
      display:flex;
      justify-content:center;
    }

    .wrap{ width:min(1040px, 100%); padding: 0 16px 18px; }
    header{
      height:64px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      position:sticky;
      top:0;
      z-index:10;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,12,18,.90), rgba(11,12,18,.55));
      border-bottom:1px solid var(--border);
    }
    .title{
      font-weight: 950;
      letter-spacing:.06em;
      text-transform: uppercase;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .badge{
      font-weight: 950;
      font-size: 11px;
      letter-spacing:.06em;
      text-transform: uppercase;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(233,236,255,.85);
    }
    .btn{
      border:none;
      border-radius: 14px;
      padding: 12px 14px;
      font-weight: 950;
      cursor:pointer;
      color:var(--text);
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.09); }
    .btn:active{ transform: translateY(1px); }

    .layout{
      margin-top: 14px;
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      align-items:start;
    }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .topline{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .theme{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 240px;
    }
    .theme .label{
      font-weight: 950;
      letter-spacing:.06em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(233,236,255,.80);
    }
    .theme .value{
      font-weight: 950;
      letter-spacing:.02em;
      font-size: 16px;
    }
    .theme .sub{
      color: var(--muted);
      font-weight: 900;
      font-size: 12px;
      line-height:1.35;
    }

    .grid{
      display:grid;
      gap:10px;
      justify-content:center;
      user-select:none;
      touch-action:none;
    }
    .cell{
      width: 52px;
      height: 52px;
      border-radius: 16px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 950;
      text-transform: uppercase;
      letter-spacing:.05em;
      background: var(--tile);
      border:1px solid rgba(255,255,255,.12);
      cursor:pointer;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
      position:relative;
    }
    .cell:hover{ background: var(--tileHover); }
    .cell:active{ transform: translateY(1px); }

    .cell.sel{
      background: var(--sel);
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 2px rgba(255,255,255,.10) inset;
    }
    .cell.found{
      background: var(--found);
      border-color: rgba(123,208,139,.32);
    }
    .cell.spangramFound{
      background: var(--spangram);
      border-color: rgba(181,140,246,.34);
    }
    .cell .dot{
      position:absolute;
      top:7px;
      right:7px;
      width:8px;
      height:8px;
      border-radius:999px;
      background: rgba(255,255,255,.0);
    }
    .cell.found .dot{ background: rgba(123,208,139,.85); }
    .cell.spangramFound .dot{ background: rgba(181,140,246,.90); }

    .controls{
      display:flex;
      gap:10px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .controls .btn{
      flex: 1 1 auto;
      text-align:center;
      background: var(--btn);
      border-color: rgba(255,255,255,.14);
    }
    .controls .btn:hover{ background: var(--btnHover); }

    .sideTitle{
      font-weight: 950;
      letter-spacing:.05em;
      text-transform: uppercase;
      margin: 0 0 10px;
      opacity:.95;
    }

    .pill{
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(233,236,255,.82);
      font-weight: 900;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .foundList{
      display:flex;
      flex-wrap: wrap;
      gap:8px;
    }
    .chip{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      font-weight: 950;
      font-size: 12px;
      letter-spacing:.03em;
      text-transform: uppercase;
      color: rgba(233,236,255,.86);
    }
    .chip.sp{ border-color: rgba(181,140,246,.35); background: rgba(181,140,246,.14); }
    .chip.th{ border-color: rgba(123,208,139,.35); background: rgba(123,208,139,.14); }

    .toast{
      position:fixed;
      top:74px;
      left:50%;
      transform:translateX(-50%);
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 950;
      backdrop-filter: blur(10px);
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease;
      max-width: calc(100% - 24px);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      z-index:9999;
    }
    .toast.show{ opacity:1; }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      .cell{ width: 48px; height: 48px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <button class="btn" id="home">⌂ Home</button>
      <div class="title">
        <span>Strands</span>
        <span class="badge" id="badge">Spangram + Theme</span>
      </div>
      <button class="btn" id="new">New</button>
    </header>

    <div class="layout">
      <div class="card">
        <div class="topline">
          <div class="theme">
            <div class="label">Theme</div>
            <div class="value" id="themeTitle">Loading…</div>
            <div class="sub" id="themeSub">Find the spangram, then the theme words.</div>
          </div>
          <div class="pill" id="status">Ready</div>
        </div>

        <div class="grid" id="grid"></div>

        <div class="controls">
          <button class="btn" id="submit">Submit</button>
          <button class="btn" id="clear">Clear</button>
          <button class="btn" id="reveal">Reveal</button>
        </div>
      </div>

      <div class="card">
        <div class="sideTitle">Found</div>
        <div class="pill" id="seed"></div>
        <div class="pill" id="progress"></div>
        <div class="foundList" id="foundList"></div>
        <div style="height:10px"></div>
        <div class="pill" style="color:rgba(233,236,255,.75); line-height:1.45;">
          Controls:
          <br/>• Click / drag to select adjacent letters (8 directions)
          <br/>• Submit to check a word
          <br/>• Clear cancels current selection
          <br/>• Reveal shows all answers for this board
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  // ====== CONFIG ======
  const ROWS = 8;
  const COLS = 6;
  const TOTAL = ROWS * COLS;

  // Theme packs. Each one has:
  // - theme title
  // - spangram (1 long phrase-ish string, letters only)
  // - theme words (multiple, letters only)
  //
  // The generator *builds the grid from these letters*, then hides the paths.
  const PACKS = [
    {
      theme: "COFFEE ORDER",
      spangram: "COFFEEHOUSEMENU",
      words: ["LATTE","MOCHA","ESPRESSO","AMERICANO","CAPPUCCINO","MACCHIATO"]
    },
    {
      theme: "MOVIE NIGHT",
      spangram: "POPCORNMOVIETIME",
      words: ["TRAILER","TICKETS","CINEMA","SCREEN","SUBTITLES","SEQUEL"]
    },
    {
      theme: "GAME DEV",
      spangram: "BUILDINGGAMEENGINE",
      words: ["SHADER","TEXTURE","MESH","PHYSICS","CAMERA","SPRITE"]
    },
    {
      theme: "MUSIC GEAR",
      spangram: "STUDIORECORDINGKIT",
      words: ["MIC","CABLE","MIXER","TRACKS","HEADPHONES","AMPLIFIER"]
    },
    {
      theme: "ROAD TRIP",
      spangram: "HIGHWAYVACATIONPLAN",
      words: ["MOTEL","MAPS","SNACKS","GAS","MILEAGE","DET0UR".replace("0","O")]
    },
    {
      theme: "KITCHEN TIME",
      spangram: "COOKINGANDMEALPREP",
      words: ["SKILLET","SPATULA","RECIPE","CHOP","BOIL","BAKE"]
    },
    {
      theme: "TECH WORDS",
      spangram: "INTERNETPROTOCOLS",
      words: ["ROUTER","PACKET","DOMAIN","SERVER","CLIENT","LATENCY"]
    },
    {
      theme: "HARDWARE",
      spangram: "COMPUTERPARTSBUILD",
      words: ["GPU","CPU","RAM","DRIVE","FANS","CASE"]
    },
  ];

  // ====== DOM ======
  const gridEl = document.getElementById("grid");
  const toastEl = document.getElementById("toast");
  const statusEl = document.getElementById("status");
  const themeTitleEl = document.getElementById("themeTitle");
  const themeSubEl = document.getElementById("themeSub");
  const seedEl = document.getElementById("seed");
  const progressEl = document.getElementById("progress");
  const foundListEl = document.getElementById("foundList");

  // ====== UTILS ======
  function toast(msg, ms=1400){
    toastEl.textContent = msg;
    toastEl.classList.add("show");
    clearTimeout(toast._t);
    toast._t = setTimeout(()=>toastEl.classList.remove("show"), ms);
  }

  function randU32(){
    const x = new Uint32Array(1);
    crypto.getRandomValues(x);
    return x[0] >>> 0;
  }
  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j = randU32() % (i+1);
      [a[i],a[j]] = [a[j],a[i]];
    }
  }
  function lettersOnly(s){
    return (s||"").toUpperCase().replace(/[^A-Z]/g,"");
  }
  function key(r,c){ return r + "," + c; }
  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

  function neighbors(r,c){
    const out = [];
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(dr===0 && dc===0) continue;
        const rr = r+dr, cc=c+dc;
        if(inBounds(rr,cc)) out.push({r:rr,c:cc});
      }
    }
    return out;
  }

  function idxOf(r,c){ return r*COLS + c; }
  function rcOf(idx){ return { r: Math.floor(idx/COLS), c: idx % COLS }; }

  function setStatus(msg, type=""){
    statusEl.textContent = msg;
    statusEl.style.color =
      type==="ok" ? "var(--ok)" :
      type==="warn" ? "var(--warn)" :
      type==="bad" ? "var(--bad)" :
      "rgba(233,236,255,.82)";
  }

  // ====== GAME STATE ======
  let puzzle = null;        // {theme, spangram, words, gridLetters[], solutionPaths: Map(word->cells[]) }
  let cells = [];           // DOM cell elements indexed by idx
  let selecting = false;
  let selection = [];       // array of idx
  let found = new Set();    // found words (including spangram)
  let revealed = false;

  // ====== RENDER GRID ======
  function buildGridDOM(letters){
    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${COLS}, 52px)`;
    gridEl.style.gridTemplateRows = `repeat(${ROWS}, 52px)`;
    cells = new Array(TOTAL);

    for(let i=0;i<TOTAL;i++){
      const {r,c} = rcOf(i);
      const el = document.createElement("div");
      el.className = "cell";
      el.id = `cell-${r}-${c}`;
      el.dataset.idx = String(i);
      el.textContent = letters[i] || "?";
      const dot = document.createElement("div");
      dot.className = "dot";
      el.appendChild(dot);

      el.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        if(revealed) return;
        selecting = true;
        startOrExtendSelection(i);
        el.setPointerCapture?.(e.pointerId);
      });
      el.addEventListener("pointerenter", ()=>{
        if(!selecting || revealed) return;
        startOrExtendSelection(i);
      });

      cells[i] = el;
      gridEl.appendChild(el);
    }

    window.addEventListener("pointerup", ()=>{ selecting=false; }, { once:false });
  }

  function cellElByIdx(i){ return cells[i]; }

  // ====== SAFE PAINT (this prevents your crash) ======
  function paintCells(idxs, addClass, removeClasses=[]){
    if(!Array.isArray(idxs)) return;
    for(const i of idxs){
      const el = cellElByIdx(i);
      if(!el) continue; // <- critical: never crash
      for(const rc of removeClasses) if(rc) el.classList.remove(rc);
      if(addClass) el.classList.add(addClass);
    }
  }

  function clearSelection(){
    paintCells(selection, null, ["sel"]);
    selection = [];
  }

  function currentString(){
    return selection.map(i => {
      const el = cellElByIdx(i);
      return el ? el.firstChild.textContent : "";
    }).join("");
  }

  function isAdjacent(a, b){
    const A = rcOf(a), B = rcOf(b);
    return Math.abs(A.r - B.r) <= 1 && Math.abs(A.c - B.c) <= 1 && !(A.r===B.r && A.c===B.c);
  }

  function startOrExtendSelection(i){
    if(selection.length === 0){
      selection = [i];
      paintCells([i], "sel");
      setStatus(currentString());
      return;
    }
    const last = selection[selection.length-1];

    // allow backtracking one step
    if(selection.length >= 2 && i === selection[selection.length-2]){
      const removed = selection.pop();
      paintCells([removed], null, ["sel"]);
      setStatus(currentString());
      return;
    }

    // must be adjacent and not already in path
    if(!isAdjacent(last, i)) return;
    if(selection.includes(i)) return;

    selection.push(i);
    paintCells([i], "sel");
    setStatus(currentString());
  }

  function markFound(word){
    const isSp = (word === puzzle.spangram);
    const path = puzzle.solutionPaths.get(word);
    if(path){
      paintCells(path, isSp ? "spangramFound" : "found");
    }
    found.add(word);
    renderFoundList();
    renderProgress();
  }

  function renderFoundList(){
    foundListEl.innerHTML = "";
    const all = [puzzle.spangram, ...puzzle.words];
    for(const w of all){
      if(!found.has(w)) continue;
      const chip = document.createElement("div");
      chip.className = "chip " + (w===puzzle.spangram ? "sp" : "th");
      chip.textContent = w;
      foundListEl.appendChild(chip);
    }
  }

  function renderProgress(){
    const totalTargets = 1 + puzzle.words.length;
    const got = found.size;
    progressEl.textContent = `Progress: ${got}/${totalTargets}`;
  }

  // ====== PUZZLE GENERATION ======
  // We need to:
  // 1) Choose a pack
  // 2) Pick a subset of theme words so total letters = grid size with the spangram
  // 3) Lay each word as an actual path in the grid (no overlaps)
  // 4) Fill letters accordingly
  //
  // This guarantees every letter belongs to a word -> NYT-like.
  function pickPack(){
    const p = PACKS[randU32() % PACKS.length];
    const sp = lettersOnly(p.spangram);
    const ws = p.words.map(lettersOnly).filter(Boolean);

    return { theme: p.theme, spangram: sp, words: ws };
  }

  function chooseWordsToFitGrid(spangram, words){
    // target letters total = TOTAL
    // we force the spangram in, then choose theme words to fill remaining letters.
    const remain = TOTAL - spangram.length;
    if(remain <= 0) throw new Error("Spangram too long for grid");

    // Greedy pick longer words first, then adjust
    const sorted = words.slice().sort((a,b)=> b.length - a.length);
    const chosen = [];
    let left = remain;

    for(const w of sorted){
      if(w.length <= left && chosen.length < 8){
        chosen.push(w);
        left -= w.length;
      }
      if(left === 0) break;
    }

    // If not exact fill, try swapping / smaller words
    if(left !== 0){
      // brute-ish small search limited
      const pool = words.slice().sort((a,b)=> a.length - b.length);
      for(let tries=0; tries<4000 && left !== 0; tries++){
        // restart attempt
        chosen.length = 0;
        left = remain;

        // random pick to try exact fill
        const bag = pool.slice();
        shuffle(bag);

        for(const w of bag){
          if(w.length <= left && chosen.length < 10){
            chosen.push(w);
            left -= w.length;
          }
          if(left === 0) break;
        }
      }
    }

    // Still not exact? pad with extra letters from spangram (allowed in this clone)
    // But to keep it “real”, we instead extend the grid by sprinkling duplicate letters
    // while still being selectable; NYT has filler letters that still belong to words.
    // Here we enforce exact fill by trimming chosen until fits, then add a SHORT word list.
    if(left !== 0){
      // try exact fill by selecting a different subset (simple backtrack)
      const pool = words.slice().filter(w => w.length <= remain);
      for(let attempt=0; attempt<2000; attempt++){
        const picked = [];
        let L = remain;
        const bag = pool.slice();
        shuffle(bag);
        for(const w of bag){
          if(w.length <= L && picked.length < 10){
            picked.push(w);
            L -= w.length;
          }
          if(L === 0) break;
        }
        if(L === 0) return picked;
      }

      // last resort: allow a couple single-letter "theme" fillers (still solvable)
      const fillers = ["A","E","I","O","U"];
      while(left > 0){
        chosen.push(fillers[randU32()%fillers.length]);
        left--;
      }
    }

    return chosen;
  }

  function emptyBoard(){
    const used = new Array(TOTAL).fill(false);
    const letters = new Array(TOTAL).fill("");
    return { used, letters };
  }

  function tryPlaceWordPath(word, board){
    // Find a random simple path of length word.length with no overlaps.
    // Start at random cell, random walk with backtracking.
    const W = word.length;
    for(let attempt=0; attempt<1800; attempt++){
      const start = randU32() % TOTAL;
      const path = [];
      const usedLocal = new Set(); // indices for this word
      function dfs(idx, pos){
        path.push(idx);
        usedLocal.add(idx);

        if(pos === W-1) return true;

        const {r,c} = rcOf(idx);
        const neigh = neighbors(r,c).map(p => idxOf(p.r,p.c));
        shuffle(neigh);

        for(const n of neigh){
          if(board.used[n]) continue;
          if(usedLocal.has(n)) continue;
          if(dfs(n, pos+1)) return true;
        }

        usedLocal.delete(idx);
        path.pop();
        return false;
      }

      if(board.used[start]) continue;
      if(dfs(start, 0)){
        // commit
        for(let i=0;i<path.length;i++){
          const idx = path[i];
          board.used[idx] = true;
          board.letters[idx] = word[i];
        }
        return path;
      }
    }
    return null;
  }

  function generatePuzzle(){
    // keep trying until we build a valid full board
    for(let attempt=0; attempt<250; attempt++){
      const pack = pickPack();
      const words = chooseWordsToFitGrid(pack.spangram, pack.words);

      const board = emptyBoard();
      const solutionPaths = new Map();

      // Place spangram first (hardest)
      const spPath = tryPlaceWordPath(pack.spangram, board);
      if(!spPath) continue;
      solutionPaths.set(pack.spangram, spPath);

      // Place theme words
      let ok = true;
      const chosenWords = [];
      for(const w of words){
        const path = tryPlaceWordPath(w, board);
        if(!path){ ok=false; break; }
        solutionPaths.set(w, path);
        chosenWords.push(w);
      }
      if(!ok) continue;

      // Ensure fully filled
      if(board.letters.some(ch => !ch)) continue;

      return {
        theme: pack.theme,
        spangram: pack.spangram,
        words: chosenWords,
        gridLetters: board.letters,
        solutionPaths
      };
    }
    throw new Error("Failed to generate puzzle");
  }

  // ====== GAME LOOP ======
  function newGame(){
    revealed = false;
    found = new Set();
    clearSelection();

    const seed = randU32().toString(16).toUpperCase();
    seedEl.textContent = `Puzzle seed: ${seed}`;

    puzzle = generatePuzzle();

    themeTitleEl.textContent = puzzle.theme;
    themeSubEl.textContent = `Spangram length: ${puzzle.spangram.length} • Theme words: ${puzzle.words.length}`;

    buildGridDOM(puzzle.gridLetters); // IMPORTANT: grid exists BEFORE any painting
    renderFoundList();
    renderProgress();
    setStatus("Ready");
    toast("New puzzle");
  }

  function submit(){
    if(!puzzle || selection.length < 3){
      toast("Select at least 3 letters");
      return;
    }
    const guess = currentString();

    // valid if equals a theme word or spangram and not already found
    const all = new Set([puzzle.spangram, ...puzzle.words]);
    if(!all.has(guess)){
      setStatus("Not a word in this puzzle", "bad");
      toast("Nope");
      return;
    }
    if(found.has(guess)){
      setStatus("Already found", "warn");
      toast("Already");
      clearSelection();
      return;
    }

    markFound(guess);
    setStatus(guess === puzzle.spangram ? "Spangram!" : "Theme word!", "ok");
    toast(guess === puzzle.spangram ? "Spangram!" : "Theme word!");
    clearSelection();

    if(found.size === (1 + puzzle.words.length)){
      setStatus("Solved!", "ok");
      toast("Solved!", 1800);
      revealed = true;
    }
  }

  function reveal(){
    if(!puzzle) return;
    revealed = true;

    // mark everything as found + paint paths
    const all = [puzzle.spangram, ...puzzle.words];
    for(const w of all){
      if(!found.has(w)) markFound(w);
    }
    setStatus("Revealed", "warn");
    toast("Revealed", 1600);
    clearSelection();
  }

  // ====== WIRE BUTTONS ======
  document.getElementById("home").addEventListener("click", ()=> location.href="index.html");
  document.getElementById("new").addEventListener("click", newGame);
  document.getElementById("submit").addEventListener("click", submit);
  document.getElementById("clear").addEventListener("click", ()=>{ clearSelection(); setStatus("Cleared"); });
  document.getElementById("reveal").addEventListener("click", reveal);

  window.addEventListener("keydown", (e)=>{
    if(e.key === "Enter") submit();
    if(e.key === "Escape") { clearSelection(); setStatus("Cleared"); }
  });

  // ====== START ======
  newGame();
})();
</script>
</body>
</html>
